# 表达式和函数

## 表达式

学过小学数学的我们应该知道，将数字和运算符连接起来的组合称之为表达式，比方说这样：

``` shell
1 + 1
5 * 8
```

我们可以将其中的数字称之为操作数，运算符可以称之为操作符。特殊的，单个操作数也可以被看作是一个特殊的表达式。

在 MySQL 中也有表达式的概念，不过操作数和操作符的含义有了扩充。下边详细看一下。

### 操作数

MySQL 中操作数可以是下边这几种类型：

1. 常数

> 常数很好理解，我们平时用到的数字、字符串、时间值什么的都可以被称为常数，它是一个确定的值，比如数字1，字符串'abc'，时间值2019-08-16 17:10:43啥的。

2. 列名

> 针对某个具体的表，它的列名可以被当作表达式的一部分，比如对于 student_info 表来说，number、name 都可以作为操作数。

3. 函数调用

> MySQL 中有函数的概念，比方说获取当前时间的函数 NOW，而在函数后边加个小括号就算是一个函数调用，比如 NOW()。

4. 标量子查询或者行子查询

5. 其他表达式

> 一个表达式也可以作为一个操作数与另一个操作数来形成一个更复杂的表达式，比方说（假设 col 是一个列名）：
> * (col - 5) / 3
> * (1 + 1) * 2 + col * 3

### 操作符

对于小白的我们来说，目前熟悉掌握下边三种操作符就应该够用了：

1. 算数操作符

> 就是加减乘除法那一堆，我们看一下 MySQL 中都支持哪些：

| 操作符 |  示例   |         描述         |
| :----: | :-----: | :------------------: |
|   +    |  a + b  |         加法         |
|   -    |  a - b  |         减法         |
|   *    |  a * b  |         乘法         |
|   /    |  a / b  |         除法         |
|  DIV   | a DIV b | 除法，取商的整数部分 |
|   %    |  a & b  |         取余         |
|   -    |   -a    |         负号         |

> 在使用 MySQL 中的算术操作符时需要注意，DIV 和 / 都表示除法操作符，但是 DIV 只会取商的整数部分，/ 会保留商的小数部分。比如表达式 2 DIV 3 的结果是0，而 2 / 3 的结果是 0.6667。

2. 比较操作符

> 就是在搜索条件中我们已经看过的比较操作符，我们把常用的都抄下来看一下：

|   操作符    |          示例          |             描述              |
| :---------: | :--------------------: | :---------------------------: |
|      =      |         a = b          |           a 等于 b            |
| <> 或者 !=  |         a <> b         |           a不等于b            |
|      <      |         a < b          |            a小于b             |
|     <=      |         a <= b         |         a小于或等于b          |
|      >      |         a > b          |            a大于b             |
|     >=      |         a >= b         |         a大于或等于b          |
|   BETWEEN   |   a BETWEEN b AND c    |       满足 b <= a <= c        |
| NOT BETWEEN | a NOT BETWEEN b AND c  |      不满足 b <= a <= c       |
|     IN      |   a IN (b1, b2, ...)   |   a是b1, b2, ... 中的某一个   |
|   NOT IN    | a NOT IN (b1, b2, ...) | a不是b1, b2, ... 中的任意一个 |
|   IS NULL   |       a IS NULL        |         a的值是 NULL          |
| IS NOT NULL |     a IS NOT NULL      |        a的值不是 NULL         |
|    LIKE     |        a LIKE b        |            a匹配b             |
|  NOT LIKE   |      a NOT LIKE b      |           a不匹配b            |

> 由比较操作符连接而成的表达式也称为布尔表达式，表示真或者假，也可以称为 TRUE 或者 FALSE。比如 1 > 3 就代表 FALSE，3 != 2 就代表 TRUE。

3. 逻辑操作符

逻辑操作符是用来将多个布尔表达式连接起来，我们需要了解这几个逻辑操作符：

| 操作符 |  示例   |                 描述                 |
| :----: | :-----: | :----------------------------------: |
|  AND   | a AND b |    只有a和b同时为真，表达式才为真    |
|   OR   | a OR b  | 只要a或b有任意一个为真，表达式就为真 |
|  XOR   | a XOR b |   a和b有且只有一个为真，表达式为真   |


### 表达式的使用

只要把这些操作数和操作符相互组合起来就可以组成一个表达式。表达式主要以下边这两种方式使用：

1. 放在查询列表中

> 我们前边都是将列名放在查询列表中的(*号代表所有的列名～)。列名只是表达式中超级简单的一种，我们可以将任意一个表达式作为查询列表的一部分来处理，比方说我们可以在查询 student_score 表时把score 字段的数据都加 100，就像这样：

``` sql
SELECT number, subject, score + 100 AS addScore FROM student_score;
```

需要注意的是，放在查询列表的表达式也可以不涉及列名，就像这样：

``` sql
SELECT 1 FROM student_info;
```

因为student_info中有6条记录，所以结果集中也就展示了6条结果。

2. 作为搜索条件

我们在介绍搜索条件的时候介绍的都是带有列名的表达式，搜索条件也可以不带列名，比如这样：

``` sql
SELECT * FROM student_info WHERE 2 > 1;
```

由于我们的搜索条件是 2 > 1，这个条件对于表中的每一条记录都成立，所以最后的查询结果就是全部的记录。不过这么写有点儿傻哈，没有一毛钱卵用，没一点实际意义～ 所以通常情况下搜索条件中都会包含列名的。

## 函数

我们在使用 MySQL 过程中经常会有一些需求，比方说将给定文本中的小写字母转换成大写字母，把某个日期数据中的月份值提取出来等等。为了解决这些常遇到的问题，设计 MySQL 的大叔贴心的为我们提供了很多所谓的函数，比方说：

* UPPER 函数是用来把给定的文本中的小写字母转换成大写字母。
* MONTH 函数是用来把某个日期数据中的月份值提取出来。
* NOW 函数用来获取当前的日期和时间。

如果我们想使用这些函数，可以在函数名后加一个小括号()就好，表示调用一下这个函数，简称函数调用。比方说 NOW() 就代表调用 NOW 函数来获取当前日期和时间。针对某些包含参数的函数，我们也可以在小括号()里将参数填入，比方说 UPPER('abc') 表示将字符串 'abc' 转换为大写格式。

下边来介绍一些常用的MySQL内置函数：

### 文本处理函数

|   名称    |          调用示例           | 示例结果  |                  描述                  |
| :-------: | :-------------------------: | :-------: | :------------------------------------: |
|   LEFT    |      LEFT('abc123', 3)      |    abc    |    给定字符串从左边取指定长度的子串    |
|   RIGHT   |     RIGHT('abc123', 3)      |    123    |    给定字符串从右边取指定长度的子串    |
|  LENGTH   |        LENGTH('abc')        |     3     |            给定字符串的长度            |
|   LOWER   |        LOWER('ABC')         |    abc    |          给定字符串的小写格式          |
|   UPPER   |        UPPER('abc')         |    ABC    |          给定字符串的大写格式          |
|   LTRIM   |        LTRIM(' abc')        |    abc    |     给定字符串左边空格去除后的格式     |
|   RTRIM   |        RTRIM('abc ')        |    abc    |     给定字符串右边空格去除后的格式     |
| SUBSTRING |  SUBSTRING('abc123', 2, 3)  |    bc1    | 给定字符串从指定位置截取指定长度的子串 |
|  CONCAT   | CONCAT('abc', '123', 'xyz') | abc123xyz |  将给定的各个字符串拼接成一个新字符串  |

我们以SUBSTRING函数为例试一下：

``` sql
SELECT SUBSTRING('abc123', 2, 3);
```

我们前边在唠叨表达式的说过，函数调用也算是一种表达式的操作数，它可以和其他操作数用操作符连接起来组成一个表达式来作为查询列表的一部分或者放到搜索条件中。我们来以 CONCAT 函数为例来看一下：

``` sql
SELECT CONCAT('学号为', number, '的学生在《', subject, '》课程的成绩是：', score) AS 成绩描述 FROM student_score;
```

### 日期和时间处理函数

下边有些函数会用到当前日期，我编辑文章的日期是 2019-08-28，在实际调用这些函数时以你的当前时间为准。

|    名称     |                    调用示例                     |      示例结果       |                             描述                             |
| :---------: | :---------------------------------------------: | :-----------------: | :----------------------------------------------------------: |
|     NOW     |                      NOW()                      | 2019-08-16 17:10:43 |                      返回当前日期和时间                      |
|   CURDATE   |                    CURDATE()                    |     2019-08-16      |                         返回当前日期                         |
|   CURTIME   |                    CURTIME()                    |      17:10:43       |                         返回当前时间                         |
|    DATE     |           DATE('2019-08-16 17:10:43')           |     2019-08-16      |               将给定日期和时间值的日期提取出来               |
|  DATE_ADD   | DATE_ADD('2019-08-16 17:10:43', INTERVAL 2 DAY) | 2019-08-18 17:10:43 |            将给定的日期和时间值添加指定的时间间隔            |
|  DATE_SUB   | DATE_SUB('2019-08-16 17:10:43', INTERVAL 2 DAY) | 2019-08-14 17:10:43 |            将给定的日期和时间值减去指定的时间间隔            |
|  DATEDIFF   |      DATEDIFF('2019-08-16', '2019-08-17');      |         -1          | 返回两个日期之间的天数（负数代表前一个参数代表的日期比较小） |
| DATE_FORMAT |          DATE_FORMAT(NOW(),'%m-%d-%Y')          |     08-16-2019      |                  用给定的格式显示日期和时间                  |

在使用这些函数时需要注意一些地方：

* 在使用 DATE_ADD 和 DATE_SUB 这两个函数时需要注意，增加或减去的时间间隔单位可以自己定义，下边是 MySQL 支持的一些时间单位：

|  时间单位   | 描述  |
| :---------: | :---: |
| MICROSECOND | 毫秒  |
|   SECOND    |  秒   |
|   MINUTE    | 分钟  |
|    HOUR     | 小时  |
|     DAY     |  天   |
|    WEEK     | 星期  |
|    MONTH    |  月   |
|   QUARTER   | 季度  |
|    YEAR     |  年   |

如果我们相让2019-08-16 17:10:43这个时间值增加2分钟，可以这么写：

``` sql
SELECT DATE_ADD('2019-08-16 17:10:43', INTERVAL 2 MINUTE);
```

* 在使用 DATE_FORMAT 函数时需要注意，我们可以通过一些所谓的格式符来自定义日期和时间的显示格式，下边是 MySQL 中常用的一些日期和时间的格式符以及它们对应的含义：

| 格式符 |                         描述                         |
| :----: | :--------------------------------------------------: |
|   %b   |          简写的月份名称(Jan、Feb、...、Dec)          |
|   %D   | 带有英文后缀的月份中的日期(0th、1st、2nd、...、31st) |
|   %d   |     数字格式的月份中的日期(00、01、02、...、31)      |
|   %f   |                微秒（000000-999999）                 |
|   %H   |              二十四小时制的小时 (00-23)              |
|   %h   |               十二小时制的小时 (01-12)               |
|   %i   |                数值格式的分钟(00-59)                 |
|   %M   |      月份名（January、February、...、December）      |
|   %m   |                数值形式的月份(00-12)                 |
|   %p   |         上午或下午（AM代表上午、PM代表下午）         |
|   %S   |                      秒(00-59)                       |
|   %s   |                      秒(00-59)                       |
|   %W   |       星期名（Sunday、Monday、...、Saturday）        |
|   %w   |     周内第几天 （0=星期日、1=星期一、 6=星期六）     |
|   %Y   |             4位数字形式的年（例如2019）              |
|   %y   |              2位数字形式的年（例如19）               |

我们可以把我们想要的显示格式用对应的格式符描述出来，就像这样：

``` sql
SELECT DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p');
```

### 数值处理函数

下边列举一些数学上常用到的函数，在遇到需要数学计算的业务时会很有用：

| 名称  |  调用示例   |      示例结果      |        描述        |
| :---: | :---------: | :----------------: | :----------------: |
|  ABS  |   ABS(-1)   |         1          |      取绝对值      |
|  Pi   |    PI()     |      3.141593      |     返回圆周率     |
|  COS  |  COS(PI())  |         -1         | 返回一个角度的余弦 |
|  EXP  |   EXP(1)    | 2.718281828459045  |  返回e的指定次方   |
|  MOD  |  MOD(5,2)   |         1          |   返回除法的余数   |
| RAND  |   RAND()    | 0.7537623539136372 |   返回一个随机数   |
|  SIN  | SIN(PI()/2) |         1          | 返回一个角度的正弦 |
| SQRT  |   SQRT(9)   |         3          | 返回一个数的平方根 |
|  TAN  |   TAN(0)    |         0          | 返回一个角度的正切 |

### 聚集函数

如果将上边介绍的那些函数以函数调用的形式放在查询列表中，那么会为表中符合 WHERE 条件的每一条记录调用一次该函数。比方说这样：

``` sql
SELECT number, LEFT(name, 1) FROM student_info WHERE number < 20180106;
```

student_info 表中符合 number < 20180106 搜索条件的每一条记录的 name 字段会依次被当作 LEFT 函数的参数，结果就是把这些人的名字的首个字符给提取出来了。但是有些函数是用来统计数据的，比方说统计一下表中的行数，某一列数据的最大值是什么，我们把这种函数称之为聚集函数，下边介绍MySQL中常用的几种聚集函数：

| 函数名 |       描述       |
| :----: | :--------------: |
| COUNT  |  返回某列的行数  |
|  MAX   | 返回某列的最大值 |
|  MIN   | 返回某列的最小值 |
|  SUM   |  返回某列值之和  |
|  AVG   | 返回某列的平均值 |

#### COUNT函数

COUNT 函数使用来统计行数的，它有下边两种使用方式：

* COUNT(*)：对表中行的数目进行计数，不管列的值是不是 NULL。
* COUNT(列名)：对特定的列进行计数，会忽略掉该列为 NULL 的行。

> 两者的区别是会不会忽略统计列的值为 NULL 的行！两者的区别是会不会忽略统计列的值为 NULL 的行！两者的区别是会不会忽略统计列的值为 NULL 的行！重要的事情说了3遍，希望你能记住。我们来数一下student_info 表中有几行记录吧：

``` sql
SELECT COUNT(*) FROM student_info;
```

#### MAX函数

MAX 函数是用来查询某列中数据的最大值，以 student_score 表中的 score 列为例来看一下：

``` sql
SELECT MAX(score) FROM student_score;
```

#### MIN函数

MIN 函数是用来查询某列中数据的最小值，以 student_score 表中的 score 列为例来看一下：

``` sql
SELECT MIN(score) FROM student_score;
```

#### SUM函数

SUM 函数是用来计算某列数据的和，还是以 student_score 表中的 score 列为例来看一下：

``` sql
SELECT SUM(score) FROM student_score;
```

#### AVG函数

AVG 函数是用来计算某列数据的平均数，还是以 student_score 表中的 score 列为例来看一下：

``` sql
SELECT AVG(score) FROM student_score;
```


#### 给定搜索条件下聚集函数的使用

聚集函数并不是一定要统计一个表中的所有记录，我们也可以指定搜索条件来限定这些聚集函数作用的范围。比方说我们只想统计'母猪的产后护理'这门课程的平均分可以这么写：

``` sql
SELECT AVG(score) FROM student_score WHERE subject = '母猪的产后护理';
```

换句话说就是：不在搜索条件中的那些记录是不参与统计的。

#### 聚集函数中DISTINCT的使用

默认情况下，上边介绍的聚集函数将计算指定列的所有非 NULL 数据，如果我们指定的列中有重复数据的话，可以选择使用 DISTINCT 来过滤掉这些重复数据。比方说我们想查看一下 student_info 表中存储了多少个专业的学生信息，就可以这么写：

``` sql
SELECT COUNT(DISTINCT major) FROM student_info;
```

#### 组合聚集函数

这些聚集函数也可以集中在一个查询中使用，比如这样：

``` sql
SELECT COUNT(*) AS 成绩记录总数, MAX(score) AS 最高成绩, MIN(score) AS 最低成绩, AVG(score) AS 平均成绩 FROM student_score;
```

## 隐式类型转换

### 隐式类型转换的场景

只要某个值的类型与上下文要求的类型不符，MySQL 就会根据上下文环境中需要的类型对该值进行类型转换，由于这些类型转换都是 MySQL 自动完成的，所以也可以被称为隐式类型转换。我们列举几种常见的隐式类型转换的场景：

1. 把操作数类型转换为适合操作符计算的相应类型。
   
  比方说对于加法操作符+来说，它要求两个操作数都必须是数字才能进行计算，所以如果某个操作数不是数字的话，会将其隐式转换为数字，比方说下边这几个例子：

``` shell
1 + 2       →   3
'1' + 2     →   3
'1' + '2'   →   3
```
  虽然'1'、'2'都是字符串，但是如果它们作为加法操作符+的操作数的话，都会被强制转换为数字，所以上边几个表达式其实都会被当作1 + 2去处理的，这些表达式被放在查询列表时的效果如下：

``` sql
SELECT 1 + 2, '1' + 2, '1' + '2';
```

2. 将函数参数转换为该函数期望的类型。

  我们拿用于拼接字符串的CONCAT函数举例，这个函数以字符串类型的值作为参数，如果我们在调用这个函数的时候，传入了别的类型的值作为参数，MySQL会自动把这些值的类型转换为字符串类型的：

``` sql
CONCAT('1', '2')    →   '12'
CONCAT('1', 2)      →   '12'
CONCAT(1, 2)        →   '12'
```

  虽然1、2都是数字，但是如果它们作为CONCAT函数的参数的话，都会被强制转换为字符串，所以上边几个表达式其实都会被当作CONCAT('1', '2)去处理的，这些表达式被放到查询列表时的效果如下：

``` sql
SELECT CONCAT('1', '2'), CONCAT('1', 2), CONCAT(1, 2);
```

3. 存储数据时，把某个值转换为某个列需要的类型。

  我们先新建一个简单的表t：

``` sql
CREATE TABLE t (
    i1 TINYINT,
    i2 TINYINT,
    s VARCHAR(100)
);
```

这个表有三个列，列i1和i2是用来存储整数的，列s是用来存储字符串的，如果我们在存储数据的时候填入的不是期望的类型，就像这样：

``` sql
INSERT INTO t(i1, i2, s) VALUES('100', '100', 200);
```

我们为列i1和i2填入的值是一个字符串值：'100'，列s填入的值是一个整数值：200，虽然说类型都不对，但是由于隐式类型转换的存在，在插入数据的时候字符串'100'会被转型为整数100，整数200会被转型成字符串'200'，所以最后插入成功。

### 类型转换的注意事项

1. MySQL 会尽量把值转换为表达式中需要的类型，而不是产生错误。

  按理说'23sfd'这个字符串无法转换为数字，但是MySQL规定只要字符串的开头部分包含数字，那么就把这个字符串转换为开头的数字，如果开头并没有包含数字，那么将被转换成0，比方说这样：

``` shell
'23sfd'         →   23
'2019-08-28'    →   2019
'11:30:32'      →   11
'sfd'           →   0
```
看个例子：

``` sql
SELECT '23sfd' + 0, 'sfd' + 0;
```

不过需要注意的是，这种强制转换不能用于存储数据中，比方说这样：

``` sql
INSERT INTO t(i1, i2, s) VALUES('sfd', 'sfd', 'aaa');
```

由于i1和i2列需要整数，而填入的字符串'sfd'并不能顺利的转为整数，所以报错了。

2. 在运算时会自动提升操作数的类型。

  比如说上面的 t 表中，i1 是 TINYINT 的数据类型，按理说能表示的最大正整数是 127，但是如果你添加数据为 200，也是可以的，MySQL 自动将整数类型的操作数提升到了 BIGINT。
